<!--
/**
 *《An Introduction to Machine Learning》
 *
 * @author dondevi
 * @create 2018-01-29
 *
 * @update 2018-01-30 dondevi
 *   1.Add historyStates
 */
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Grid Maze</title>
  <script src="https://d3js.org/d3.v4.min.js"></script>
</head>
<body>

  <script>
    ((window, document) => {
      "use strict";

      /**
       * -----------------------------------------------------------------------
       *  Data
       * -----------------------------------------------------------------------
       */
      const finalState = [
        1, 2, 3,
        8, 0, 4,
        7, 6, 5,
      ];
      const initialState = [
        0, 2, 1,
        6, 7, 4,
        3, 8, 5,
      ];

      let searchState = initialState.slice();
      let historyStates = [];


      /**
       * -----------------------------------------------------------------------
       *  Render
       * -----------------------------------------------------------------------
       */
      let svg = d3.select("body").append("svg")
          .attr("width", 300)
          .attr("height", 300);

      function draw () {
        let gs = svg.selectAll("g");
        let update = gs.data(searchState, d => d);
        let enter = update.enter().append("g");
        enter.append("rect")
            .attr("width", 100)
            .attr("height", 100)
            .attr("stroke", "#000")
            .attr("fill", d => 0 === d ? "#ccc" : "#fff");
        enter.append("text")
            .attr("x", 50)
            .attr("y", 52)
            .attr("stroke", d => 0 === d ? "none" : "#000")
            .attr("text-anchor", "middle")
            .text(d => d);
        update.merge(enter).transition().duration(300)
            .attr("transform", (d, i) => {
              let x = i % 3 * 100;
              let y = Math.floor(i / 3) * 100;
              return `translate(${x}, ${y})`;
            });
      }


      /**
       * -----------------------------------------------------------------------
       *  Main
       * -----------------------------------------------------------------------
       */
      draw();

      let count = 1;
      let interval = d3.interval(() => {
        count += 1;
        algorithm(res => {
          window.alert((res ? "Success": "Fail") + " " + count);
          interval.stop();
        });
      }, 300);


      /**
       * -----------------------------------------------------------------------
       *  Function
       * -----------------------------------------------------------------------
       */

      /**
       * Algorithm iteration
       */
      function algorithm (callback) {
        let searchStates = searcher(searchState);
        let searchResult = searchStates.map(searchState => {
          return { searchState, evaluation: evaluator(finalState, searchState) };
        });
        if (!searchResult[0]) {
          return callback && callback(false);
        }
        searchResult.sort((a, b) => {
          if (a.evaluation === b.evaluation) {
            return [-1, 1][Math.round(Math.random())];
          }
          return a.evaluation - b.evaluation;
        });
        searchState = searchResult[0].searchState;
        historyStates.push(searchState.join());
        draw();
        if (0 === searchResult[0].evaluation) {
          return callback && callback(true);
        }
      }

      /**
       * Searcher
       * @param  {Array} searchState
       * @return {Array} searchStates for next step
       */
      function searcher () {
        let blankIndex = searchState.indexOf(0);
        let siblingOffsets = [-3, 1, 3, -1];
        return siblingOffsets.map(siblingOffset => {
          let itemIndex = blankIndex + siblingOffset;
          if ((2 === blankIndex % 3 && 1 === siblingOffset)
            || (0 === blankIndex % 3 && -1 === siblingOffset)
            || !searchState[itemIndex]) {
            return null;
          }
          let cloneState = searchState.slice();
          [cloneState[blankIndex], cloneState[itemIndex]] =
          [cloneState[itemIndex], cloneState[blankIndex]];
          if (-1 < historyStates.indexOf(cloneState.join())) {
            return null;
          }
          return cloneState;
        }).filter(searchState => searchState);
      }

      /**
       * Evaluator
       * @param  {Array} finalState
       * @param  {Array} searchState
       * @return {Number} evaluation
       */
      function evaluator (finalState, searchState) {
        return finalState.reduce((stepSum, finalItem, finalIndex) => {
          let searchIndex = searchState.indexOf(finalItem);
          let stepX = Math.abs(finalIndex - searchIndex) % 3;
          let stepY = Math.floor(Math.abs(finalIndex - searchIndex) / 3);
          return stepSum + stepX + stepY;
        }, 0);
      }

    })(window, document);
</script>

</body>
</html>
