<!--
/**
 *《AI Introduction to Machine Learning》
 *
 * @author dondevi
 * @create 2018-01-29
 */
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>AI Introduction to Machine Learning</title>
  <script src="https://d3js.org/d3.v4.min.js"></script>
</head>
<body>

  <script>
    ((window, document) => {
      "use strict";

      const finalState = [
        1, 2, 3,
        8, 0, 4,
        7, 6, 5,
      ];

      let searchState = [
        0, 2, 1,
        6, 7, 4,
        3, 8, 5,
      ];

      let svg = d3.select("body").append("svg")
          .attr("width", 300)
          .attr("height", 300);

      function redraw () {
        let gs = svg.selectAll("g");
        let update = gs.data(searchState, d => d);
        let enter = update.enter().append("g");
        enter.append("rect")
            .attr("width", 100)
            .attr("height", 100)
            .attr("stroke", d => 0 === d ? "none" : "#000")
            .attr("fill", d => 0 === d ? "#ccc" : "#fff");
        enter.append("text")
            .attr("x", 50)
            .attr("y", 50)
            .attr("stroke", d => 0 === d ? "none" : "#000")
            .attr("text-anchor", "middle")
            .text(d => d);
        update.merge(enter).transition().duration(500)
            .attr("transform", (d, i) => {
              let x = i % 3 * 100;
              let y = Math.floor(i / 3) * 100;
              return `translate(${x}, ${y})`;
            });
      }


      redraw();
      let interval = d3.interval(algorithm, 1000);
      interval.count = 1;

      /**
       * Algorithm iteration
       */
      function algorithm () {
        let searchStates = searcher(searchState);
        let searchResult = searchStates.map(searchState => {
          return { searchState, evaluation: evaluator(finalState, searchState) };
        });
        searchResult.sort((a, b) => {
          if (a.evaluation === b.evaluation) {
            return [-1, 1][Math.round(Math.random())];
          }
          return a.evaluation - b.evaluation;
        });
        if (0 === searchResult[0].evaluation) {
          console.log(interval.count);
          return interval.stop();
        }
        interval.count += 1;
        searchState = searchResult[0].searchState;
        redraw();
      }

      /**
       * Searcher
       * @param  {Array} searchState
       * @return {Array} searchStates for next step
       */
      function searcher (searchState) {
        let blankIndex = searchState.indexOf(0);
        let siblingOffsets = [-3, 1, 3, -1];
        return siblingOffsets.map(siblingOffset => {
          let itemIndex = blankIndex + siblingOffset;
          if ((2 === blankIndex % 3 && 1 === siblingOffset)
            || (0 === blankIndex % 3 && -1 === siblingOffset)
            || !searchState[itemIndex]) {
            return null;
          }
          let cloneState = searchState.slice();
          [cloneState[blankIndex], cloneState[itemIndex]] =
          [cloneState[itemIndex], cloneState[blankIndex]];
          return cloneState;
        }).filter(searchState => searchState);
      }

      /**
       * Evaluator
       * @param  {Array} finalState
       * @param  {Array} searchState
       * @return {Number} evaluation
       */
      function evaluator (finalState, searchState) {
        return finalState.reduce((stepSum, finalItem, finalIndex) => {
          let searchIndex = searchState.indexOf(finalItem);
          let stepX = Math.abs(finalIndex - searchIndex) % 3;
          let stepY = Math.floor(Math.abs(finalIndex - searchIndex) / 3);
          let weight = 1;
          // let siblingOffsets = [-3, 1, 3, -1];
          // siblingOffsets.forEach(siblingOffset => {
          //   if (0 === searchState[finalIndex + siblingOffset]) {
          //     weight = 2;
          //   }
          // });
          return stepSum + (stepX + stepY) * weight;
        }, 0);
      }

    })(window, document);
</script>

</body>
</html>
